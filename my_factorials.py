#  PYTHON FACTORIALS OF NUMBERS

# def fact(n):
#     f = 1
#     for i in range(1, n+1):
#         f*=i
#     return f
# mbda a : a * n

# mydoubler = myfunc(2)

# print(mydoubler(11))
# x = 6
# result = fact(x)
# print(result)

    #  second sample

# def fact(n):
#     if n < 0:
#         return f"Undefined Result"
#     elif n ==0 or n == 1:
#         return 1
#     else:
#         return n * fact(n-1)
    
# x = 1
# result = fact(x)
# print(result)


#   FEBONACHI NUMBERS

# def fib(n):
#     a = 0
#     b = 1
#     if n<= 0:
#         return[]
    
#     elif n == 1:
#         return a
#     else:
#         my_fibseq = [a, b]
#         for i in range(2, n):
#             c = a + b
#             a = b
#             b = c
#             my_fibseq.append(c)
#         return my_fibseq

# fib_num = int(input("Enter the number you wish to check: "))

# fibonacci_seq = fib(fib_number)
# print(f"the fibonacci sequence for first (fib_num) numbers is: ")

    #  arbirary python functions
    
# def my_funct(child1, child2,child3):
#     print(f"the first child is {chidi},\nthe secondchild is {child2}, \nthe third child is {child3}")

# my_func(child3= "mark", child2= "emil", child1= "linus")


# def my_function(food):
#     for x in food:
#         print(x)
# fruits = ["apple", "banana", "cherry"]

# my_function(fruits)


#    PYTHON LAMBDA


#  x = lambda a : a + 10
# print(x(5))


# x = lambda a, b : a * b
# print(x(5, 6))

#    WHY USE LAMBDA

# def myfunc(n):
#   return la



